import { Message, GuildMember, VoiceState } from 'discord.js';
import { configRepository } from '../database/repositories/configRepository';
import { activityLogRepository } from '../database/repositories/activityLogRepository';
import { XP_CONFIG, ANTI_EXPLOIT } from '../utils/constants';
import { simpleHash, stringSimilarity } from '../utils/helpers';
import { logger } from '../utils/logger';
import { SpamDetectionResult, CooldownData } from '../types';

class AntiExploitService {
  // In-memory cooldowns (resets on bot restart)
  private messageCooldowns: Map<string, number> = new Map();
  private reactionCooldowns: Map<string, number> = new Map();
  private messageHistory: Map<string, string[]> = new Map();
  private recentMessages: Map<string, number[]> = new Map();
  private penalizedUsers: Map<string, number> = new Map();

  /**
   * Check if user can gain XP from message
   */
  async canGainMessageXP(message: Message): Promise<{ allowed: boolean; reason?: string }> {
    const userId = message.author.id;
    const guildId = message.guild?.id;

    if (!guildId) return { allowed: false, reason: 'No guild' };

    // Check if user is penalized (in timeout)
    if (this.isUserPenalized(userId)) {
      return { allowed: false, reason: 'User penalized' };
    }

    // Check if channel is blacklisted
    const isBlacklisted = await configRepository.isChannelBlacklisted(guildId, message.channel.id);
    if (isBlacklisted) {
      return { allowed: false, reason: 'Channel blacklisted' };
    }

    // Check if any role is blacklisted
    const member = message.member;
    if (member) {
      for (const role of member.roles.cache.values()) {
        const roleBlacklisted = await configRepository.isRoleBlacklisted(guildId, role.id);
        if (roleBlacklisted) {
          return { allowed: false, reason: 'Role blacklisted' };
        }
      }
    }

    // Check message length
    if (message.content.length < XP_CONFIG.MIN_MESSAGE_LENGTH) {
      return { allowed: false, reason: 'Message too short' };
    }

    // Check cooldown
    if (this.isOnMessageCooldown(userId)) {
      return { allowed: false, reason: 'Cooldown active' };
    }

    // Check for spam
    const spamResult = this.detectSpam(message);
    if (spamResult.isSpam) {
      await this.applyPenalty(userId, spamResult.reason!, spamResult.penalty || 0);
      return { allowed: false, reason: spamResult.reason };
    }

    // Check for repeated messages
    if (this.isRepeatedMessage(userId, message.content)) {
      await this.logSuspicious(userId, 'repeated_message', { content: message.content.slice(0, 100) });
      return { allowed: false, reason: 'Repeated message' };
    }

    // Set cooldown
    this.setMessageCooldown(userId);

    // Track message for spam detection
    this.trackMessage(userId, message.content);

    return { allowed: true };
  }

  /**
   * Check if user can gain XP from reaction
   */
  async canGainReactionXP(
    userId: string,
    guildId: string,
    messageAuthorId: string,
    messageId: string
  ): Promise<{ allowed: boolean; reason?: string }> {
    // Can't react to own messages
    if (userId === messageAuthorId) {
      return { allowed: false, reason: 'Self reaction' };
    }

    // Check if user is penalized
    if (this.isUserPenalized(userId)) {
      return { allowed: false, reason: 'User penalized' };
    }

    // Check cooldown
    if (this.isOnReactionCooldown(userId)) {
      return { allowed: false, reason: 'Cooldown active' };
    }

    // Set cooldown
    this.setReactionCooldown(userId);

    return { allowed: true };
  }

  /**
   * Check if voice session is valid for XP
   */
  async isValidVoiceSession(
    voiceState: VoiceState,
    membersInChannel: number
  ): Promise<{ valid: boolean; reason?: string }> {
    const userId = voiceState.member?.id;
    const guildId = voiceState.guild.id;

    if (!userId) return { valid: false, reason: 'No user' };

    // Check minimum members in channel
    if (membersInChannel < XP_CONFIG.MIN_VOICE_MEMBERS) {
      return { valid: false, reason: 'Not enough members' };
    }

    // Check if in AFK channel
    if (voiceState.channel?.id === voiceState.guild.afkChannelId) {
      return { valid: false, reason: 'AFK channel' };
    }

    // Check if channel is blacklisted
    if (voiceState.channel) {
      const isBlacklisted = await configRepository.isChannelBlacklisted(guildId, voiceState.channel.id);
      if (isBlacklisted) {
        return { valid: false, reason: 'Channel blacklisted' };
      }
    }

    // Check if self-muted for too long (basic check)
    // Note: Full mute tracking would require persistent storage
    if (voiceState.selfMute && voiceState.selfDeaf) {
      return { valid: false, reason: 'Self muted and deafened' };
    }

    return { valid: true };
  }

  /**
   * Detect spam in message
   */
  private detectSpam(message: Message): SpamDetectionResult {
    const userId = message.author.id;
    const now = Date.now();

    // Get recent message timestamps
    const recentTimestamps = this.recentMessages.get(userId) || [];

    // Filter to messages within spam window
    const windowStart = now - (ANTI_EXPLOIT.SPAM_WINDOW_SECONDS * 1000);
    const messagesInWindow = recentTimestamps.filter(t => t > windowStart);

    // Check for message flood
    if (messagesInWindow.length >= ANTI_EXPLOIT.MAX_MESSAGES_IN_WINDOW) {
      return {
        isSpam: true,
        reason: 'Message flood detected',
        penalty: ANTI_EXPLOIT.SPAM_PENALTY_XP,
      };
    }

    // Track this message timestamp
    messagesInWindow.push(now);
    this.recentMessages.set(userId, messagesInWindow);

    // Check for automated message patterns
    if (this.looksLikeBot(message.content)) {
      return {
        isSpam: true,
        reason: 'Automated message pattern',
        penalty: ANTI_EXPLOIT.SPAM_PENALTY_XP,
      };
    }

    return { isSpam: false };
  }

  /**
   * Check if message looks automated
   */
  private looksLikeBot(content: string): boolean {
    // Check for common bot patterns (less aggressive)
    const botPatterns = [
      /^(.)\1{10,}$/, // Repeated single character 10+ times (e.g., "aaaaaaaaaa")
      /^[0-9]{10,}$/, // Only numbers 10+ digits
      /(.{3,})\1{5,}/, // Same pattern repeated 5+ times
    ];

    return botPatterns.some(pattern => pattern.test(content.trim()));
  }

  /**
   * Check if message is repeated
   */
  private isRepeatedMessage(userId: string, content: string): boolean {
    const history = this.messageHistory.get(userId) || [];
    const contentHash = simpleHash(content);

    // Check exact matches
    if (history.includes(contentHash)) {
      return true;
    }

    // Check similar messages
    for (const prevContent of history.slice(-5)) {
      if (stringSimilarity(contentHash, prevContent) > ANTI_EXPLOIT.SIMILAR_MESSAGE_THRESHOLD) {
        return true;
      }
    }

    return false;
  }

  /**
   * Track message for future spam detection
   */
  private trackMessage(userId: string, content: string): void {
    const history = this.messageHistory.get(userId) || [];
    const contentHash = simpleHash(content);

    history.push(contentHash);

    // Keep only recent messages
    if (history.length > ANTI_EXPLOIT.MESSAGE_HISTORY_SIZE) {
      history.shift();
    }

    this.messageHistory.set(userId, history);
  }

  /**
   * Check if user is on message cooldown
   */
  private isOnMessageCooldown(userId: string): boolean {
    const lastMessage = this.messageCooldowns.get(userId);
    if (!lastMessage) return false;
    return Date.now() - lastMessage < XP_CONFIG.MESSAGE_COOLDOWN;
  }

  /**
   * Set message cooldown
   */
  private setMessageCooldown(userId: string): void {
    this.messageCooldowns.set(userId, Date.now());
  }

  /**
   * Check if user is on reaction cooldown
   */
  private isOnReactionCooldown(userId: string): boolean {
    const lastReaction = this.reactionCooldowns.get(userId);
    if (!lastReaction) return false;
    return Date.now() - lastReaction < XP_CONFIG.REACTION_COOLDOWN;
  }

  /**
   * Set reaction cooldown
   */
  private setReactionCooldown(userId: string): void {
    this.reactionCooldowns.set(userId, Date.now());
  }

  /**
   * Check if user is penalized
   */
  isUserPenalized(userId: string): boolean {
    const penaltyEnd = this.penalizedUsers.get(userId);
    if (!penaltyEnd) return false;

    if (Date.now() > penaltyEnd) {
      this.penalizedUsers.delete(userId);
      return false;
    }

    return true;
  }

  /**
   * Clear penalty for user (admin)
   */
  clearPenalty(userId: string): void {
    this.penalizedUsers.delete(userId);
    this.messageCooldowns.delete(userId);
    this.reactionCooldowns.delete(userId);
    this.messageHistory.delete(userId);
    this.recentMessages.delete(userId);
  }

  /**
   * Apply penalty to user
   */
  private async applyPenalty(userId: string, reason: string, xpPenalty: number): Promise<void> {
    const penaltyDuration = ANTI_EXPLOIT.SPAM_TIMEOUT_MINUTES * 60 * 1000;
    this.penalizedUsers.set(userId, Date.now() + penaltyDuration);

    logger.antiExploit(userId, reason, xpPenalty);

    await activityLogRepository.logSuspicious(userId, 'penalty_applied', {
      reason,
      xpPenalty,
      timeoutMinutes: ANTI_EXPLOIT.SPAM_TIMEOUT_MINUTES,
    });
  }

  /**
   * Log suspicious activity
   */
  private async logSuspicious(userId: string, action: string, details: Record<string, unknown>): Promise<void> {
    logger.suspicious(userId, action, details);
    await activityLogRepository.logSuspicious(userId, action, details);
  }

  /**
   * Get user suspicious activity count
   */
  async getSuspiciousCount(userId: string): Promise<number> {
    return activityLogRepository.getUserSuspiciousCount(userId);
  }

  /**
   * Clear all cooldowns (for testing or reset)
   */
  clearAllCooldowns(): void {
    this.messageCooldowns.clear();
    this.reactionCooldowns.clear();
    this.messageHistory.clear();
    this.recentMessages.clear();
    this.penalizedUsers.clear();
  }

  /**
   * Get remaining cooldown time for user
   */
  getRemainingCooldown(userId: string, type: 'message' | 'reaction'): number {
    const cooldownMap = type === 'message' ? this.messageCooldowns : this.reactionCooldowns;
    const cooldownTime = type === 'message' ? XP_CONFIG.MESSAGE_COOLDOWN : XP_CONFIG.REACTION_COOLDOWN;

    const lastAction = cooldownMap.get(userId);
    if (!lastAction) return 0;

    const elapsed = Date.now() - lastAction;
    return Math.max(0, cooldownTime - elapsed);
  }

  /**
   * Validate invite for XP
   */
  async isValidInvite(
    inviterId: string,
    invitedUserId: string,
    joinedAt: Date,
    memberCount: number
  ): Promise<{ valid: boolean; reason?: string }> {
    // Check if inviter is the same as invited (shouldn't happen but check anyway)
    if (inviterId === invitedUserId) {
      return { valid: false, reason: 'Self invite' };
    }

    // Check if member stayed for minimum time
    const minStayMs = XP_CONFIG.INVITE_MIN_STAY_HOURS * 60 * 60 * 1000;
    const memberAge = Date.now() - joinedAt.getTime();

    if (memberAge < minStayMs) {
      return { valid: false, reason: 'Member too new' };
    }

    // Get inviter's daily invite count
    const dailyInvites = await activityLogRepository.getRecentActionsCount(
      inviterId,
      'invite',
      24 * 60 * 60 * 1000 // 24 hours
    );

    if (dailyInvites >= XP_CONFIG.MAX_INVITES_PER_DAY) {
      return { valid: false, reason: 'Daily invite limit reached' };
    }

    return { valid: true };
  }
}

export const antiExploitService = new AntiExploitService();
export default antiExploitService;
